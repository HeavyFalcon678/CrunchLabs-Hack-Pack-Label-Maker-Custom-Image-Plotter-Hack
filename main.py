code = """//This is the Custom Image hack for the Hack Pack LabelMaker

//////////////////////////////////////////////////
                //  LIBRARIES  //
//////////////////////////////////////////////////
#include <Wire.h>
#include <LiquidCrystal_I2C.h>
#include <Stepper.h>
#include <ezButton.h>
#include <Servo.h>

//////////////////////////////////////////////////
          //  PINS AND PARAMETERS  //
//////////////////////////////////////////////////

LiquidCrystal_I2C lcd(0x27, 16, 2);  // Set the LCD address to 0x27 for a 16x2 display

ezButton button1(14); //joystick button handler
#define INIT_MSG "Initializing..."
#define MODE_NAME "PLOT CUSTOM IMG "
#define PLOTTING "   PLOTTING...  "

// Set the grid resolution and desired drawing width (in steps)
// (Change GRID_SIZE here in the Python-generated code to 25, 40, etc.)
#define GRID_SIZE %s
#define DESIRED_WIDTH %s
// Compute the scale factor so that (GRID_SIZE * customImagescale) equals DESIRED_WIDTH
int customImagescale = DESIRED_WIDTH / GRID_SIZE;

//////////////////////////////////////////////////
//  JOYSTICK, MOTOR, SERVO, ETC. SETUP
//////////////////////////////////////////////////

const int joystickXPin = A2;  
const int joystickYPin = A1;  
const int joystickButtonThreshold = 200;

int currentCharacter = 0;
int cursorPosition = 0;
int currentPage = 0;
const int charactersPerPage = 16;

const int stepCount = 200;
const int stepsPerRevolution = 2048;
Stepper xStepper(stepsPerRevolution, 6,8,7,9);
Stepper yStepper(stepsPerRevolution, 2,4,3,5);

int xPins[4] = {6, 8, 7, 9};
int yPins[4] = {2, 4, 3, 5};

const int SERVO_PIN  = 13;
Servo servo;
int angle = 30;

enum State { MainMenu, Editing, PrintConfirmation, Printing, plotCustomImg };
State currentState = MainMenu;
State prevState = Printing;

enum jState {LEFT, RIGHT, UP, DOWN, MIDDLE, UPRIGHT, UPLEFT, DOWNRIGHT, DOWNLEFT};
jState joyState = MIDDLE;
jState prevJoyState = MIDDLE;

boolean pPenOnPaper = false;
int lineCount = 0;

int xpos = 0;
int ypos = 0;
const int posS = 2;
const int posM = 7;
const int posL = 12;
bool joyUp;
bool joyDown;
bool joyLeft;
bool joyRight;
int button1State;
int joystickX;
int joystickY;

// This value is generated by the Python script (number of points)
const long customImageSize = %s;

//////////////////////////////////////////////////
                //  CUSTOM IMAGE VECTOR  //
//////////////////////////////////////////////////

// Format: Each point is stored as {x, y} (pen up/down is controlled in the drawing routine)
const uint8_t customImage[][2] = %s
;

//////////////////////////////////////////////////
                //  S E T U P  //
//////////////////////////////////////////////////
void setup() {
  lcd.init();
  lcd.backlight();
  lcd.setCursor(0, 0);
  lcd.print(INIT_MSG);

  pinMode(LED_BUILTIN, OUTPUT);
  Serial.begin(9600);
  button1.setDebounceTime(50);
  servo.attach(SERVO_PIN);
  servo.write(angle);

  plot(false);

  yStepper.setSpeed(10);
  xStepper.setSpeed(8);

  penUp();
  homeYAxis();

  ypos = 0;
  xpos = 0;

  releaseMotors();
  lcd.clear();
}

////////////////////////////////////////////////
                //  L O O P  //
////////////////////////////////////////////////
void loop() {

  button1.loop();
  button1State = button1.getState();

  joystickX = analogRead(joystickXPin);
  joystickY = analogRead(joystickYPin);
  joyUp = joystickY < (512 - joystickButtonThreshold);
  joyDown = joystickY > (512 + joystickButtonThreshold);
  joyLeft = joystickX < (512 - joystickButtonThreshold);
  joyRight = joystickX > (512 + joystickButtonThreshold);

  switch (currentState) {
    case plotCustomImg:
      {
        if (prevState != plotCustomImg){
          lcd.clear();
          lcd.setCursor(0,0);
          lcd.print(MODE_NAME);
          lcd.setCursor(0,1);
          lcd.print(PLOTTING);
          cursorPosition = 5;
          prevState = plotCustomImg;
        }
        lcd.setCursor(cursorPosition, 1);
        plotcustomImage();
        homeYAxis();
        releaseMotors();
        lcd.clear();
        currentState = MainMenu;
        prevState = plotCustomImg;
      }
      break;
    
    case MainMenu:
      {
        if (prevState != MainMenu){
          lcd.clear();
          lcd.setCursor(0,0);
          lcd.print(MODE_NAME);
          lcd.setCursor(0,1);
          lcd.print("      START     ");
          cursorPosition = 5;
          prevState = MainMenu;
        }
        lcd.setCursor(cursorPosition, 1);
        lcd.blink();
        if (button1.isPressed()) {
          lcd.clear();
          lcd.noBlink();
          currentState = plotCustomImg;
          prevState = MainMenu;
        }
      }
      break;
  }
}

void line(int newx, int newy, bool drawing) {
  if (drawing < 2) {
      plot(drawing);
  }
  
  int i;
  long over = 0;
  
  long dx  = newx - xpos;
  long dy  = newy - ypos;
  int dirx = dx > 0 ? -1 : 1;
  int diry = dy > 0 ? 1 : -1;
  dx = abs(dx);
  dy = abs(dy);
  
  if (dx > dy) { 
    over = dx / 2; 
    for (i = 0; i < dx; i++) {
      xStepper.step(dirx);
      over += dy;
      if (over >= dx) {
        over -= dx;
        yStepper.step(diry);
      }
    }
  } else {
    over = dy / 2;
    for (i = 0; i < dy; i++) {
      yStepper.step(diry);
      over += dx;
      if (over >= dy) {
        over -= dy;
        xStepper.step(dirx);
      }
    }
  }
  
  xpos = newx;
  ypos = newy;
}

void plot(boolean penOnPaper) {
  if (penOnPaper)
    angle = 80;
  else
    angle = 25;
    
  servo.write(angle);
  if (penOnPaper != pPenOnPaper) delay(50);
  pPenOnPaper = penOnPaper;
}

void penUp(){
  servo.write(25);
}

void penDown(){
  servo.write(80);
}

void releaseMotors() {
  for (int i = 0; i < 4; i++) {
    digitalWrite(xPins[i], 0);
    digitalWrite(yPins[i], 0);
  }
  plot(false);
}

void homeYAxis(){
  yStepper.step(-3000);
}

void plotcustomImage(){
  Serial.println("CUSTOM IMG TIME");
  for (int i = 0; i < customImageSize; i++){
    int x_end = (customImage[i][0]) * customImagescale;
    int y_end = (customImage[i][1]) * customImagescale * 2.65;
    
    Serial.print("X_goal: ");
    Serial.print(x_end);
    Serial.print(" Y_goal: ");
    Serial.print(y_end);
    Serial.print(" Draw: ");
    Serial.println(customImage[i][2]);
    
    line(x_end, y_end, 0);
    penDown();
    delay(80);
    penUp();
    delay(80);
  }
  releaseMotors();
}"""


from sys import *
from sys import argv
import numpy as np
from PIL import Image
import matplotlib.pyplot as plt
from os.path import exists

# Variables
place_on_dark = argv[2]
string = str(argv[1])
chopped = ""
N = 4
while N > 0:
    chopped += string[-N]
    N -= 1

if exists(argv[1]) and (chopped == ".png" or chopped == ".jpg" or chopped == "jpeg"):
    image_path = argv[1]
else:
    print("ERROR: Image not found or invalid filename.")
    exit()

place_on_dark = int(place_on_dark)

# Change this value for higher resolution (e.g. 40 instead of 25)
grid_size = 40 # Change to 40 for more dots in the same space

# Define the fixed physical width (in steps) for the drawing.
desired_width = 1350


def generate_dot_positions(image_path, grid_size=20, place_on_dark=False):
    image = Image.open(image_path)
    image = image.convert('L')  # Convert to greyscale
    image = image.resize((grid_size, grid_size))  # Resize image to grid dimensions

    image = image.rotate(-90)  # Rotate if necessary
    pixels = np.array(image)
    average_brightness = np.mean(pixels)

    dot_positions = []
    for i in range(grid_size):
        nextCol = []
        for j in range(grid_size):
            if (place_on_dark and pixels[i, j] < average_brightness) or (
                    not place_on_dark and pixels[i, j] > average_brightness):
                nextCol.append((i, j))
        if i % 2 == 1:
            nextCol.reverse()
        dot_positions.extend(nextCol)

    return dot_positions


def plot_dots(dot_positions, grid_size=20):
    if dot_positions:
        x_coords, y_coords = zip(*dot_positions)
    else:
        x_coords, y_coords = [], []

    # Adjust y-coordinates for display
    y_coords = [grid_size - 1 - y for y in y_coords]

    plt.figure(figsize=(6, 6))
    plt.scatter(x_coords, y_coords, color='black')
    plt.xlim(0, grid_size)
    plt.ylim(0, grid_size)
    plt.title("Image Preview")
    plt.gca().invert_yaxis()
    plt.gca().set_aspect('equal', adjustable='box')
    plt.grid(True)
    plt.show(block=False)


def checkMakeFile():
    makeFile = input("Do you want to create code for this image? (Y/n) > ")
    if makeFile.lower() in ["y", "1", "true"]:
        print("Writing file...")
        writeFile()
    elif makeFile.lower() in ["n", "0", "false"]:
        print("No file created. Exiting...")
        exit()
    else:
        print("Not a valid option. Options: (Y/N)")
        checkMakeFile()


def writeFile():
    filename = "LabelMakerCustomImage.ino"
    with open(filename, 'w') as file:
        generatedCode = code % (grid_size, desired_width, len(dots), img)
        file.write(generatedCode)
    print(f"Arduino code file created. Filename: {filename}")
    print("Exiting...")
    exit()


# Process image and show preview
dots = generate_dot_positions(image_path, grid_size, place_on_dark)
plot_dots(dots, grid_size)

img = ""
for ch in str(dots):
    if ch == "(":
        img += "{"
    elif ch == ")":
        img += "}"
    elif ch == "[":
        img += "{"
    elif ch == "]":
        img += "}"
    else:
        img += ch

length = len(dots)

checkMakeFile()

# Wait until the plot window is closed
plotNum = plt.gcf().number
while plt.fignum_exists(plotNum):
    plt.pause(0.1)
